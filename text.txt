Throughout the three different time challenges I focused on writing clear, efficient, and well-structured solutions under time pressure. Each of the problems required choosing an appropriate data structure that balanced performance with readability. 

For Rotate Right, I used a deque from the Python's collections module because its built-in rotate() method performs rotayions efficently in O(1) time without complex index manipulation. This simplified the implementation and minimized debugging. For running total with reset, I selected a lsit to preserve order and efficiently append cumulative totals. Lists naturally fit problems that involve sequential accumulation, and the logic was east to reason through using a simple loop. For remove every k-th Value, I used a list again, iterating through the collection and skipping every k-th element with the help of enumerate(). This approach kept the algorithm clean and predictable with O(n) time complexity. 

The 30-minute time constraint shaped my design decisions by encouraging me to favor simplicity and correctness over unnecessary optimization. I made sure to test edge cases early, such as empty lists and boundary values, to confirm correctness before refining my code. 

The main trade-offs I accepted were minor space overhead and avoiding in-place modification in favor of clarity. Each solution emphasizes maintainable logic and well-choosen structutres-qualities interviewers value as much as algorithmic efficiency. Overall, these challeneges reinforced how important it is to think strategically about data structure selection and problem-solving under realistice time constraints. 
